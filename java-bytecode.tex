\chapter{Generazione del Java Bytecode}\label{chap:java-bytecode}
%
\vspace*{-2ex}
\begin{center}
\includegraphics[width=6.5cm]{cat9.jpg}
\end{center}
%\vspace*{-2ex}

Il Kitten bytecode \e molto semplice, poich\'e non \e necessario
preoccuparsi dell'esistenza di forme ottimizzate della stessa istruzione,
o dell'assenza di bytecode per alcune operazioni su alcuni tipi.
\E quindi ideale per la generazione del codice intermedio e la
sua eventuale ottimizzazione. A partire dal bytecode Kitten, \e poi possibile
generare del codice eseguibile. Questo codice eseguibile
potrebbe essere specifico di una data architettura su cui si intende
eseguire il programma, come ad esempio il linguaggio macchina
x86, oppure essere indipendente dalla macchina, basato quindi su
un bytecode astratto eseguibile su una qualche macchina virtuale.
In questo capitolo seguiremo la seconda strada ed esamineremo
la generazione del codice eseguibile in Java bytecode.

Il Java bytecode somiglia al Kitten bytecode, nel senso che le sue
istruzioni operano su uno stack degli operandi, su delle variabili
locali e su uno stack di attivazione. Anche le singole istruzioni e
la tecnica di chiamata e ritorno da metodo sono molto simili a quelle
del Kitten bytecode. \E per\`o un linguaggio meno esplicitamente
tipato, nel senso che, per ridurre l'occupazione in memoria,
molte istruzioni non riportano esplicitamente i
tipi su cui operano, quando questi tipi possono essere inferiti a partire
dal programma.
Il Java bytecode \e specificato in forma binaria all'interno di file
Java eseguibili detti \emph{file classe}.

La generazione del Java bytecode all'interno dei file classe \e tecnicamente
complessa per vari motivi:

\begin{enumerate}
\item a una singola istruzione del Kitten bytecode potrebbero corrispondere
      \piu istruzioni alternative del Java bytecode, variamente ottimizzate.
      Idealmente, occorre scegliere l'alternativa migliore in termini di
      occupazione in byte e di tempo di esecuzione;
\item ad alcune istruzioni del Kitten bytecode potrebbe non corrispondere
      una singola istruzione del Java bytecode, ma una sequenza di \piu
      istruzioni;
\item la struttura a blocchi del Kitten bytecode deve essere linearizzata in
      una sequenza di istruzioni, introducendo numeri di linea e,
      ove necessario, delle istruzioni di salto esplicito;
\item la sequenza di istruzioni deve infine essere trasformata in codice
      binario, facendo corrispondere a ogni istruzioni un byte, seguito da
      una qualche codifica dei suoi operandi, sempre in termini di byte;
\item i salti all'interno del Java bytecode devono venire specificati come offset
      di numeri di linea dal punto di partenza a quello di arrivo. Per
      salti particolarmente lunghi, per cui l'offset va in overflow,
      occorre creare dei \emph{punti di appoggio} intermedi;
\item le costanti del linguaggio (numeriche o stringhe) devono essere
      inserite all'interno di una tavola delle costanti del file classe.
      Nel caso in cui occorressero \piu volte nel codice, conviene
      riciclare la stessa costante piuttosto che inserirne due identiche
      nella tavola delle costanti.
\end{enumerate}
%
Tutti questi problemi giustificano l'utilizzo di una libreria di
supporto per la creazione e manipolazione del Java bytecode. Abbiamo
quindi scelto di utilizzare a tale scopo
la libreria BCEL (ByteCode Engineering Library).

\section{La generazione del Java bytecode per i bytecode Kitten sequenziali}
  \label{sec:java_bytecode_sequenziale}

Abbiamo detto che a una singola istruzione del Kitten bytecode potrebbero
corrisponderne \piu di una del Java bytecode. Per questo motivo, il metodo
di traduzione da Kitten bytecode in Java bytecode per i bytecode sequenziali
\e definito dentro \texttt{bytecode/NonBranchingBytecode.java} come
%
\begin{verbatim}
  public abstract InstructionList generateJavaBytecode
                                   (JavaClassGenerator classGen);
\end{verbatim}
%
Il tipo di ritorno di tale metodo
\e \texttt{InstructionList}, \cioe una classe di BCEL che rappresenta
una sequenza (eventualmente vuota) di bytecode Java.
L'oggetto passato come argomento \e il generatore di Java bytecode, che vedremo
alla fine del capitolo. Per adesso, ci interessa solo sapere che al
suo interno esiste una \emph{fattoria di istruzioni}, \cioe una classe
di BCEL che aiuta il programmatore a generare Java bytecode. Ad esempio,
tale fattoria ci aiuter\`a nella scelta dell'istruzione \piu ottimizzata
quando saremo davanti a \piu alternative e inserir\`a automaticamente
delle costanti nella tavola delle costanti, per quei bytecode Java che
utilizzano delle costanti. Tale fattoria pu\`o essere ottenuta invocando
\texttt{classGen.getFactory()}.

\begin{figure}
\begin{center}
\begin{tabular}{l|l}
\multicolumn{1}{c}{Kitten} &
\multicolumn{1}{c}{Java} \\\hline\hline
$\mathtt{nop}$ & $\mathtt{nop}$ \\\hline
$\mathtt{pop}$ $t$ & $\mathtt{pop}$ \\\hline
$\mathtt{dup}$ $t$ & $\mathtt{dup}$ \\\hline
$\mathtt{const}\ \mathit{nil}$ & $\mathtt{aconst\_null}$\\\hline
$\mathtt{const}\ \mathit{float\_number}$ & $\mathtt{fconst}\ \mathit{float\_number}$\\\hline
$\mathtt{const -\!\!1,0,1,2,3}$ & $\mathtt{iconst -\!\!1,0,1,2,3}$\\\hline
$\mathtt{const}\ \mathit{8\_bits\_integer}$ & $\mathtt{bipush}\ \mathit{8\_bits\_integer}$\\\hline
$\mathtt{const}\ \mathit{16\_bits\_integer}$ & $\mathtt{sipush}\ \mathit{16\_bits\_integer}$\\\hline
$\mathtt{const}\ \mathit{32\_bits\_integer}$ & $\mathtt{ldc}\ \mathit{32\_bits\_integer}$\\\hline
$\mathtt{const}\ \mathit{true}$ & $\mathtt{iconst\ 1}$\\\hline
$\mathtt{const}\ \mathit{false}$ & $\mathtt{iconst\ 0}$\\\hline
$\mathtt{load\ \mathit{l}\ of\ type\ int,boolean}$ & $\mathtt{iload\ \mathit{l}}$\\\hline
$\mathtt{load\ \mathit{l}\ of\ type\ float}$ & $\mathtt{fload\ \mathit{l}}$\\\hline
$\mathtt{load\ \mathit{l}\ of\ type\ nil,\mathit{reference}}$ & $\mathtt{aload\ \mathit{l}}$\\\hline
$\mathtt{store\ \mathit{l}\ of\ type\ int,boolean}$ & $\mathtt{istore\ \mathit{l}}$\\\hline
$\mathtt{store\ \mathit{l}\ of\ type\ float}$ & $\mathtt{fstore\ \mathit{l}}$\\\hline
$\mathtt{store\ \mathit{l}\ of\ type\ nil,\mathit{reference}}$ & $\mathtt{astore\ \mathit{l}}$\\\hline
$\mathtt{neg\ int}$ & $\mathtt{ineg}$\\\hline
$\mathtt{neg\ float}$ & $\mathtt{fneg}$\\\hline
$\mathtt{neg\ boolean}$ & $\begin{array}{rl}
                            & \mathtt{ifeq}\ \mathit{after} \\
                            & \mathtt{iconst\ 0} \\
                            & \mathtt{goto}\ \mathit{end}\\
                            \mathit{after:} & \mathtt{iconst\ 1}\\
                            \mathit{end:} & \mathtt{nop}
                           \end{array}$\\\hline
$\mathtt{add\ int}$ & $\mathtt{iadd}$\\\hline
$\mathtt{add\ float}$ & $\mathtt{fadd}$\\\hline
$\mathtt{add/sub/div/mul\ int}$ & $\mathtt{iadd/isub/idiv/imul}$\\\hline
$\mathtt{add/sub/div/mul\ float}$ & $\mathtt{fadd/fsub/fdiv/fmul}$\\\hline
$\mathtt{or}$ & $\mathtt{ior}$\\\hline
$\mathtt{and}$ & $\mathtt{iand}$\\\hline
\end{tabular}
\end{center}
\caption{La traduzione da bytecode Kitten a bytecode Java (1/3).}
  \label{fig:kitten_into_java_1}
\end{figure}

\begin{figure}
\begin{center}
\begin{tabular}{l|l}
\multicolumn{1}{c}{Kitten} &
\multicolumn{1}{c}{Java} \\\hline\hline
$\mathtt{eq\ int}$ & $\begin{array}{rl}
                            & \mathtt{if\_icmpeq}\ \mathit{after} \\
                            & \mathtt{iconst\ 0} \\
                            & \mathtt{goto}\ \mathit{end}\\
                            \mathit{after:} & \mathtt{iconst\ 1}\\
                            \mathit{end:} & \mathtt{nop}
                           \end{array}$\\\hline
$\mathtt{eq\ float}$ & $\begin{array}{rl}
                            & \mathtt{fcmpl} \\
                            & \mathtt{ifeq}\ \mathit{after} \\
                            & \mathtt{iconst\ 0} \\
                            & \mathtt{goto}\ \mathit{end}\\
                            \mathit{after:} & \mathtt{iconst\ 1}\\
                            \mathit{end:} & \mathtt{nop}
                           \end{array}$\\\hline
$\mathtt{eq\ \mathit{reference}}$ & $\begin{array}{rl}
                            & \mathtt{if\_acmpeq}\ \mathit{after} \\
                            & \mathtt{iconst\ 0} \\
                            & \mathtt{goto}\ \mathit{end}\\
                            \mathit{after:} & \mathtt{iconst\ 1}\\
                            \mathit{end:} & \mathtt{nop}
                           \end{array}$\\\hline
$\mathtt{new\ }\mathit{\kappa}$ & $\mathtt{new\ }\mathit{\kappa}$ \\\hline
$\mathtt{newstring}\ \mathit{string}$ & $\begin{array}{rl}
                            & \mathtt{new\ runTime.String} \\
                            & \mathtt{dup} \\
                            & \mathtt{ldc}\ \mathit{string}\\
                            & \mathtt{invokespecial\ runTime.String.\langle init\rangle():void}
                           \end{array}$\\\hline
$\mathtt{newarray\ of\ \mathtt{int/float/boolean}}$ & $\mathtt{newarray\ \mathtt{int/float/boolean}}$ \\\hline
$\mathtt{newarray\ of\ \mathit{reference}}$ & $\mathtt{anewarray\ \mathit{reference}}$ \\\hline
$\mathtt{cast\ int\ into\ float}$ & $\mathtt{i2f}$ \\\hline
$\mathtt{cast\ float\ into\ int}$ & $\mathtt{f2i}$ \\\hline
$\mathtt{cast}\ \mathit{reference}_1\ \mathtt{into}\ \mathit{reference}_2$ & $\mathtt{checkcast}\ \mathit{reference}_2$\\\hline
$\mathtt{getfield\ }\kappa.f$ & $\mathtt{getfield\ }\kappa.f$ \\\hline
$\mathtt{putfield\ }\kappa.f$ & $\mathtt{putfield\ }\kappa.f$ \\\hline
$\mathtt{arrayload\ from\ array\ of\ int}$ & $\mathtt{iaload}$ \\\hline
$\mathtt{arrayload\ from\ array\ of\ float}$ & $\mathtt{faload}$ \\\hline
$\mathtt{arrayload\ from\ array\ of\ boolean}$ & $\mathtt{baload}$ \\\hline
$\mathtt{arrayload\ from\ array\ of\ }\mathit{reference}$ & $\mathtt{aaload}$ \\\hline
$\mathtt{arraystore\ into\ array\ of\ int}$ & $\mathtt{iastore}$ \\\hline
$\mathtt{arraystore\ into\ array\ of\ float}$ & $\mathtt{fastore}$ \\\hline
$\mathtt{arraystore\ into\ array\ of\ boolean}$ & $\mathtt{bastore}$ \\\hline
$\mathtt{arraystore\ into\ array\ of\ }\mathit{reference}$ & $\mathtt{aastore}$ \\\hline
\end{tabular}
\end{center}
\caption{La traduzione da bytecode Kitten a bytecode Java (2/3).}
  \label{fig:kitten_into_java_2}
\end{figure}

\begin{figure}
\begin{center}
\begin{tabular}{l|l}
\multicolumn{1}{c}{Kitten} &
\multicolumn{1}{c}{Java} \\\hline\hline
$\mathtt{constructorcall\ \kappa(}$$\vec{t}$$\mathtt{):void}$ & $\mathtt{invokespecial\ \kappa.\langle init\rangle(}$$\vec{t}$$\mathtt{):void}$ \\\hline
$\mathtt{virtualcall\ \kappa.\mathit{m}(}$$\vec{t}$$\mathtt{):\mathit{t'}}$ & $\mathtt{invokevirtual\ \kappa.\mathit{m}(}$$\vec{t}$$\mathtt{):\mathit{t'}}$ \\\hline
$\mathtt{return\ int}$ & $\mathtt{ireturn}$ \\\hline
$\mathtt{return\ float}$ & $\mathtt{freturn}$ \\\hline
$\mathtt{return\ boolean}$ & $\mathtt{ireturn}$ \\\hline
$\mathtt{return}\ \mathit{reference}$ & $\mathtt{areturn}$ \\\hline
$\mathtt{return\ void}$ & $\mathtt{return}$ \\\hline
\end{tabular}
\end{center}
\caption{La traduzione da bytecode Kitten a bytecode Java (3/3).}
  \label{fig:kitten_into_java_3}
\end{figure}

Esaminiamo alcuni esempi di ridefinizione di tale metodo all'interno delle
sottoclassi dei bytecode Kitten. Le Figure~\ref{fig:kitten_into_java_1},
\ref{fig:kitten_into_java_2} and~\ref{fig:kitten_into_java_3} riportano
la lista dei bytecode Kitten e la loro traduzione in bytecode Java. Il primo
esempio \e quello del bytecode Kitten $\mathtt{nop}$, a cui corrisponde un
identico Java bytecode. L'implementazione in \texttt{bytecode/NOP.java} \e quindi semplicissima:
%
\begin{verbatim}
  public InstructionList generateJavaBytecode
      (JavaClassGenerator classGen) {
    return new InstructionList(InstructionFactory.NOP);
  }
\end{verbatim}
%
ritorniamo \cioe una lista di una singola istruzione, una $\mathtt{nop}$. Usiamo qui un
campo statico
della fattoria BCEL che ci permette di fare riferimento a un'istruzione gi\`a creata, al posto
di costruirla ogni volta tramite un costruttore.

Nel caso del bytecode Kitten $\mathtt{pop}\ \mathit{t}$, la traduzione in Java bytecode
semplicemente non riporta esplicitamente il tipo del valore duplicato, dal momento che sar\`a
inferibile. All'interno di \texttt{bytecode/POP.java} scriviamo:
%
\begin{verbatim}
  public InstructionList generateJavaBytecode
      (JavaClassGenerator classGen) {
    // non usiamo il campo type
    return new InstructionList(InstructionFactory.POP);
  }
\end{verbatim}
%
La traduzione del bytecode Kitten $\mathtt{const}\ \mathit{constant}$ \e \piu complessa,
dal momento che ci sono \piu alternative in Java bytecode, che occupano una quantit\`a
variabile di byte. Conseguentemente \e meglio scegliere la versione \piu ottimizzata fra le alternative
disponibili per la specifica $\mathit{constant}$,
come mostrato nella Figura~\ref{fig:kitten_into_java_1}. Dentro
\texttt{bytecode/CONST.java} scriviamo quindi:
%
\begin{verbatim}
  public InstructionList generateJavaBytecode
      (JavaClassGenerator classGen) {
    if (constant == null)
      return new InstructionList
                     (new org.apache.bcel.generic.ACONST_NULL());
    else
      return new InstructionList
                     (classGen.getFactory().createConstant(constant));
  }
\end{verbatim}
%
Con la prima alternativa dell'\texttt{if} gestiamo il caso in cui la costante sia \texttt{nil}.
Con la seconda gestiamo tutti gli altri casi, usando la fattoria BCEL per scegliere il bytecode
\piu ottimizzato per la costante specifica per cui stiamo compilando. Senza l'aiuto di questa fattoria,
avremmo dovuto considerare noi tutti i casi e il relativo bytecode Java \piu ottimizzato per
ciascun caso.

Un altro esempio di utilizzo della fattoria \e per il bytecode Kitten $\mathtt{load}$. Il
corrispondente bytecode Java riporta il numero della variabile locale letta, ma non il suo tipo,
\poiche \e comunque inferibile (Figura~\ref{fig:kitten_into_java_1}). Notiamo qui che
il tipo \texttt{boolean} \e implementato tramite interi (0 significa falso e ogni altro valore vero).
Dentro \texttt{bytecode/LOAD.java} scriviamo:
%
\begin{verbatim}
  public InstructionList generateJavaBytecode
      (JavaClassGenerator classGen) {
    // non usiamo il campo type
    return new InstructionList
                 (InstructionFactory.createLoad(type.toBCEL(), varNum));
  }
\end{verbatim}
%
dove il tipo Kitten viene tradotto nel corrispondente tipo Java bytecode e quindi pasato
alla fattoria per scegliere il bytecode Java corrispondente a quel tipo.

Per adesso a ogni bytecode Kitten \e sempre corrisposta una lista di bytecode Java di lunghezza unitaria.
Nel caso del bytecode Kitten $\mathtt{neg\ boolean}$, la sua traduzione in Java bytecode
\e fatta invece da una lista di 5 istruzioni (Figura~\ref{fig:kitten_into_java_1}). Dentro
\texttt{bytecode/NEG.java} scriviamo:
%
\begin{verbatim}
  public InstructionList generateJavaBytecode
      (JavaClassGenerator classGen) {
    InstructionList il = new InstructionList();

    if (type == BooleanType.INSTANCE) {
      InstructionHandle end = il.insert(InstructionFactory.NOP);
      InstructionHandle after = il.insert(InstructionFactory.ICONST_1);
      il.insert(new org.apache.bcel.generic.GOTO(end));
      il.insert(InstructionFactory.ICONST_0);
      il.insert(new org.apache.bcel.generic.IFEQ(after));
    }
    else
      ((NumericalType) type).neg(il);
    
    return il;
   }
\end{verbatim}
%
Il caso non booleano \e gestito da un metodo \texttt{neg(il)} che aggiunge alla
lista di istruzioni \texttt{il} il bytecode di negazione specifico per quel tipo.
Nel caso della negazione booleana, non esiste un corrispondente bytecode Java di negazione.
Viene costruita invece una lista di 5 bytecode Java che
controllano se il valore in cima allo stack \e falso (\cioe 0) e in tal caso
lo sostituiscono con il valore 1 (\cioe vero); se il valore \e invece vero (diverso da 0)
lo sostituiscono con il valore 0 (\cioe falso). Il metodo BCEL \texttt{insert()}
permette di inserire un bytecode Java all'inizio di una lista di istruzioni.
Tale metodo ritorna un riferimento (\texttt{InstructionHandle}) che \e utile nei casi
in cui si debba costruire un salto a tale punto del codice. Si noti che il riferimento deve
essere ottenuto prima di costruire il salto, per cui il codice viene tipicamente
costruito dall'ultima istruzione verso la prima, come in questo esempio
per $\mathtt{neg\ boolean}$.

Passando alla Figura~\ref{fig:kitten_into_java_2}, \e interessante considerare il caso
della generazione di un booleano a partire dal confronto fra due valori. Non esistendo
Java bytecode corrispondenti, occorre costruire del codice che confronta i due valori
in cima allo stack e lascia sullo stack il valore intero 0 (\cioe falso) se il
confronto \e fallito e il valore intero 1 (\cioe vero) se il confronto ha avuto successo.
Questo caso \e simile a quello del $\mathtt{neg\ boolean}$ visto prima, ma si complica
ulteriormente per l'assenza di Java bytecode per il test di uguaglianza fra
numeri in virgola mobile (che ipoteticamente avrebbe dovuto chiamarsi $\mathtt{if\_fcmpeq}$).
Al suo posto, la compilazione di $\mathtt{eq\ float}$ utilizza il bytecode Java
$\mathtt{fcmpl}$, che consuma i due \texttt{float} $f_1$ ed $f_2$ in cima allo stack
($f_2$ sta sopra $f_1$) e li sostituisce con $-1$ se $f_1$ \e il minore,
con $0$ se sono uguali e con $1$ se $f_2$ \e il minore. Dopo questo controllo,
basta quindi usare il bytecode Java $\mathtt{ifeq}$ per controllare se la cima dello
stack \e $0$, \cioe se $f_1$ era uguale a $f_2$.

Per la creazione di un oggetto per un letterale di tipo stringa, occorre tenere
conto che le stringhe in Kitten sono implementate dalla classe di supporto
\texttt{runTime/String.java}, per cui
dobbiamo generare del codice che crea un'istanza di tale classe e la inizializza chiamandone
il costruttore. Dentro \texttt{bytecode/NEWSTRING.java} scriviamo:
%
\begin{verbatim}
  public InstructionList generateJavaBytecode
      (JavaClassGenerator classGen) {

    InstructionFactory factory = classGen.getFactory();
    InstructionList il = new InstructionList();
    String kittenStringName = runTime.String.class.getName();

    il.insert(factory.createInvoke
      (kittenStringName, // class name of the method
      Constants.CONSTRUCTOR_NAME, // name of the method
      org.apache.bcel.generic.Type.VOID, // return type
      new org.apache.bcel.generic.Type[] // parameters types
        { org.apache.bcel.generic.Type.getType("Ljava/lang/String;") },
      Constants.INVOKESPECIAL)); // invokespecial

    il.insert(factory.createConstant(value));
    il.insert(InstructionFactory.DUP);
    il.insert(factory.createNew(kittenStringName));

    return il;
   }
\end{verbatim}
%
Tale codice usa la fattoria BCEL per creare il Java bytecode $\mathtt{new}$ che
crea l'oggetto (in modo da arricchiere la tabella delle costanti),
per creare il bytecode che carica sullo stack il valore della stringa e
per creare il bytecode di invocazione del costruttore. Qui usiamo
il bytecode Java \texttt{invokespecial}, che \e obbligatorio per
invocare i costruttori\footnote{Tale bytecode effettua la ricerca del metodo
a partire dalla classe specificata staticamente nel codice ed \e quindi
ideale anche per la compilazione delle chiamate a un metodo della superclasse,
come con \texttt{super.m(\ldots)} in Java. Nel caso dei costruttori, il
bytecode $\mathtt{invokespecial}$ fallisce se il costruttore non si trova nella classe
indicata, senza effettuare la ricerca nella superclasse, \poiche in Java i
costruttori non si ereditano.}.

La traduzione del bytecode Kitten $\mathtt{cast}$ d\`a origine a un Java bytecode di
conversione di tipo oppure a un vero e proprio bytecode di cast controllato ($\mathtt{checkcast}$),
per i tipi riferimento. La lettura e scrittura sugli array genera un Java bytecode
specifico per ogni tipo di elemento degli array, ma per i tipi riferimento astrae dal
tipo degli elementi, \poiche esso \e inferibile dal contesto. Si noti l'esistenza di bytecode
specifici di creazione e accesso ad array di booleani, al fine di lasciare all'implementazione
della Java Virtual Machine la possibilit\`a di ottimizzare l'occupazione in memoria
degli array di booleani, riservando potenzialmente un bit per ciascun elemento dell'array
(ogni Java Virtual Machine pu\`o decidere se ottimizzare o meno questo caso).

La Figura~\ref{fig:kitten_into_java_3} riporta la traduzione dei bytecode Kitten per
l'invocazione e il ritorno da metodo e costruttore. La chiamata a un costruttore
viene tradotta nel bytecode Java $\mathtt{invokespecial}$ mentre la chiamata a
un metodo viene tradotta nel bytecode Java $\mathtt{invokevirtual}$, che esegue la
ricerca dell'implementazione del metodo a partire dal tipo dinamico del ricevitore
presente sullo stack. Il bytecode Kitten $\mathtt{return}\ \mathit{t}$ viene tradotto
in bytecode Java diversi a seconda del tipo $\mathit{t}$.

\section{La generazione del Java bytecode per i bytecode Kitten di diramazione}
  \label{sec:java_bytecode_diramazione}

I bytecode Kitten di diramazione vengono tradotti in salti all'interno del Java bytecode
corrispondente. Conseguentemente, la loro traduzione richiede di conoscere il punto
di codice \textit{yes} a cui bisogna saltare se il test della diramazione \e vero.
La Figura~\ref{fig:kitten_into_java_condition} riporta la traduzione di ciascun
bytecode Kitten di diramazione, supponendo che quando la condizione \e vera il controllo
passi al punto \textit{yes}. A partire da tale tabella e per ogni bytecode di diramazione
$b$, \e quindi possibile generare del codice che controlla il test espresso da $b$,
va al punto \textit{yes} se tale test \e vero e al punto \textit{no} se invece \e falso,
usando il bytecode Java $\mathtt{goto}$:
%
\[\begin{array}{l}
  \mathit{codice\ per\ b\ che\ va\ a\ yes\ se\ soddisfatto,\ come\ in\ Figura~\ref{fig:kitten_into_java_condition}} \\
  \mathtt{goto}\ \mathit{no}
\end{array}\]
%
L'implementazione di tale generazione di codice Java bytecode \e realizzata
dentro la classe \texttt{bytecode/BranchingBytecode.java}:
%
\begin{verbatim}
  public final InstructionList generateJavaBytecode
      (JavaClassGenerator classGen,
       InstructionHandle yes, InstructionHandle no) {

    InstructionList il = new InstructionList();

    // builds the instructions that go to yes if the test is true
    generateJavaBytecodeAux(il, classGen, yes);

    il.append(new org.apache.bcel.generic.GOTO(no));
    
    return il;
  }

  protected abstract void generateJavaBytecodeAux
    (InstructionList il, JavaClassGenerator classGen,
     InstructionHandle yes);
\end{verbatim}
%
Si noti come le etichette \textit{yes} e \textit{no} siano realizzate tramite
\texttt{InstructionHandle} BCEL, \cioe riferimenti a punti di codice. Il metodo
\texttt{generateJavaBytecode()} \e \texttt{final} e delega al metodo astratto ausiliario
\texttt{generateJavaBytecodeAux()}
la generazione del codice specifico a ciascun bytecode di diramazione. Quest'ultimo
metodo implementa la traduzione in Figura~\ref{fig:kitten_into_java_condition},
in ciascuna sottoclasse di \texttt{bytecode/BranchingBytecode.java}.

\begin{figure}
\begin{center}
\begin{tabular}{l|l}
\multicolumn{1}{c}{Kitten} &
\multicolumn{1}{c}{Java} \\\hline\hline
$\mathtt{if\_true}$ & $\mathtt{ifne}\ \mathit{yes}$ \\\hline
$\mathtt{if\_false}$ & $\mathtt{ifeq}\ \mathit{yes}$ \\\hline
$\mathtt{if\_cmplt\ int}$ & $\mathtt{if\_icmplt}\ \mathit{yes}$ \\\hline
$\mathtt{if\_cmplt\ float}$ & $\begin{array}{rl}
                            & \mathtt{fcmpl} \\
                            & \mathtt{iflt}\ \mathit{yes}
                           \end{array}$\\\hline
$\mathtt{if\_cmpeq\ int}$ & $\mathtt{if\_icmpeq}\ \mathit{yes}$ \\\hline
$\mathtt{if\_cmpeq\ float}$ & $\begin{array}{rl}
                            & \mathtt{fcmpl} \\
                            & \mathtt{ifeq}\ \mathit{yes}
                           \end{array}$\\\hline
$\mathtt{if\_cmpeq}\ \mathit{reference}$ & $\mathtt{if\_acmpeq}\ \mathit{yes}$ \\\hline
\end{tabular}
\end{center}
\caption{La traduzione da bytecode Kitten di diramazione a bytecode Java che salta
al punto \textit{yes} se la condizione di diramazione \e soddisfatta.
La traduzione di $\mathtt{if\_cmpgt}$, $\mathtt{if\_cmple}$ e $\mathtt{if\_cmpge}$
\e simile a quella di $\mathtt{if\_cmplt}$. La traduzione di
$\mathtt{if\_cmpne}$ \e simile a quella di $\mathtt{if\_cmpeq}$.}
  \label{fig:kitten_into_java_condition}
\end{figure}

\section{La generazione del Java bytecode per un grafo di blocchi di Kitten bytecode}
  \label{sec:kitten_into_java_block}

Nelle Sezioni~\ref{sec:java_bytecode_sequenziale} e~\ref{sec:java_bytecode_diramazione}
abbiamo visto come ogni singolo bytecode Kitten dia origina a una sequenza di uno o
\piu bytecode Java. In questa sezione mostriamo come sia possibile generare una
sequenza di bytecode Java a partire da un grafo di istruzioni in bytecode Kitten,
come per esempio quello della Figura~\ref{fig:fib_bytecode}.

La prima osservazione \e che un simile grafo contiene dei blocchi all'interno dei quali
ci sono bytecode sequenziali, tranne per il primo bytecode di ciascun blocco, che
potrebbe essere un bytecode di diramazione, accoppiato a un bytecode di diramazione
opposto nel blocco fratello. Ne consegue che la traduzione del codice Kitten interno
a ciascun blocco si pu\`o effettuare concatenando semplicemente la traduzione
in Java bytecode di ciascun bytecode sequenziale al suo interno. Questo \e quello
che accade dentro una sequenza di bytecode, \cioe dentro \texttt{bytecode/BytecodeList.java}:

{\small\begin{verbatim}
  public InstructionList generateJavaBytecode(JavaClassGenerator classGen) {
    InstructionList result;

    if (head instanceof NonBranchingBytecode)
      result = ((NonBranchingBytecode) head).generateJavaBytecode(classGen);
    else
      result = new InstructionList();

    if (tail != null)
      result.append(tail.generateJavaBytecode(classGen));

    if (result.isEmpty())
      result.append(new org.apache.bcel.generic.NOP());

    return result;
  }
\end{verbatim}}

\noindent
Si tratta di una semplice discesa ricorsiva sulla lista di bytecode Kitten,
che concatena il bytecode Java generato per ciascun bytecode Kitten, scartando i
bytecode di diramazione. Il test finale serve a garantire che non si ritorni mai
una lista vuota di bytecode Java.

Siamo adesso nelle condizioni di poter generare il codice per un blocco di codice
e legarlo a quello dei blocchi che lo seguono, ricorsivamente. Si tratta di un
algoritmo ricorsivo che scende sul grafo dei blocchi, traducendo man mano
il codice in ciascun blocco. Dal momento che in genere si tratta di un grafo
e non di un albero aciclico, dobbiamo garantire che questo algoritmo termini,
evitando \cioe che entri in loop nel caso in cui ci siano dei cicli di blocchi di
codice. A tal fine, teniamo nota dei blocchi gi\`a processati (\texttt{done}),
annotando per ciascun di essi un riferimento
(\texttt{InstructionHandle}) all'inizio del codice Java generato per tale blocco.
In questo modo possiamo controllare se un blocco \e gi\`a stato tradotto e non
ritradurlo; inoltre siamo capaci di saltare all'inizio del codice per ogni
blocco gi\`a tradotto. Il codice \e dentro
\texttt{javaBytecodeGenerator/JavaClassGenerator.java}:

{\scriptsize
\begin{verbatim}
  private InstructionHandle generateJavaBytecode
      (Block block, Map<Block, InstructionHandle> done, InstructionList instructions) {
 
    InstructionHandle result = done.get(block);
    if (result != null)  // gia' tradotto?
      return result;  // ritorniamo un riferimento all'inizio del codice gia' tradotto

    // aggiungiamo la traduzione del codice Kitten presente nel blocco
    result = instructions.append(block.getBytecode().generateJavaBytecode(this));

    // annotiamolo come traduzione per il blocco: in futuro potra' servire
    done.put(block, result);

    // procediamo ricorsivamente sui successivi blocchi
    generateJavaBytecodeFollows(block, done, instructions);

    // ritorniamo la traduzione del bytecode nel blocco
    return result;
  }

  private void generateJavaBytecodeFollows
      (Block block, Map<Block, InstructionHandle> done, InstructionList instructions) {

    List<Block> follows = block.getFollows();

    // fine del bytecode generato fino a questo momento
    InstructionHandle ourLast = instructions.getEnd();

    if (!follows.isEmpty())  // ci sono blocchi successori?
      if (follows.get(0).getBytecode().getHead() instanceof BranchingBytecode) {
        // una condizione segue il blocco: la estraiamo
        BranchingBytecode condition = (BranchingBytecode) follows.get(0).getBytecode().getHead();

        // generiamo e aggiungiamo il codice per le due alternative
        InstructionHandle noH = generateJavaBytecode(follows.get(1), done, instructions);
        InstructionHandle yesH = generateJavaBytecode(follows.get(0), done, instructions);

        // nel mezzo aggiungiamo del codice che valuta la condizione e va alle due alternative
        instructions.append(ourLast, condition.generateJavaBytecode(this, yesH, noH));
      }
      else {
        // c'e' solo un successore: non e' una condizione. Generiamo il suo codice
        InstructionHandle followJB = generateJavaBytecode(follows.get(0), done, instructions);

        // nel mezzo mettiamo un salto al codice del successore
        instructions.append(ourLast, new GOTO(followJB));
      }
  }
\end{verbatim}}

\noindent
Il metodo \texttt{generateJavaBytecodeFollows()} processa i successori di un blocco,
generandone il codice e aggiungendolo
alla fine di \texttt{instructions}. In questo modo
\texttt{instructions} si va arricchendo con il codice dei vari blocchi tradotti,
distesi in una sequenza lineare. Occorre per\`o \emph{incollare} il codice di
un blocco con quello dei suoi successori. Ecco \perche usiamo la variabile
\texttt{ourLast}: essa contiene un riferimento alla fine delle istruzioni
gi\`a generate all'inizio del metodo, prima di processare i suoi successori.
Sar\`a in quel punto che dovremo aggiungere del codice che salta all'inizio del
codice per le due alternative di una condizione (\texttt{yesH} e \texttt{noH})
oppure per il singolo successore sequenziale (\texttt{followJB}).
Nel primo caso usiamo il metodo di traduzione dei bvytecode di diramazione,
visto nella Sezione~\ref{sec:java_bytecode_diramazione}. Nel secondo
basta un semplice \texttt{goto}. Potrebbe non essere ovvio il motivo per cui
aggiungiamo questo \texttt{goto}. In fondo, \texttt{ourLast} punta alla fine
del codice Java bytecode gi\`a generato per un blocco, che deve essere seguito
in questo caso dal codice per il suo unico successsore. Va per\`o osservato che
il codice per il successore potrebbe essere stato generato in passato (abbiamo
a che fare con un grafo, non con un albero) e quindi potrebbe non venire aggiunto
subito dopo \texttt{ourLast} ma trovarsi gi\`a generato dentro \texttt{instructions},
prima di \texttt{ourLast}. Il \texttt{goto} ci permette di gestire correttamente entrambe
le situazioni. Al limite finiamo per aggiungere un \texttt{goto} all'istruzione
successiva, inutile ma non dannoso. Se teniamo all'ottimizzazione, potremo sempre eliminarlo dopo con un
semplice algoritmo di pulizia del Java bytecode generato, che ne elimina le ridondanze.
Questo \e proprio quello che accade nel metodo principale di generazione del Java bytecode
presente dentro \texttt{javaBytecodeGenerator/JavaClassGenerator.java}: esso genera il
bytecode Java a partire da un blocco di codice, creando una mappa vuota per \texttt{done};
poi elimina ridondanze (\texttt{goto} a istruzioni immediatamente seguenti, \texttt{nop}
inutili) e ritorna il risultato:
%
\begin{verbatim}
  public InstructionList generateJavaBytecode(Block block) {
    InstructionList instructions = new InstructionList();

    generateJavaBytecode
      (block, new HashMap<Block, InstructionHandle>(), instructions);

    return removeRedundancies(instructions);
  }
\end{verbatim}

\section{La generazione del Java bytecode per le classi Kitten}
  \label{sec:kitten_signatures_into_java}
%
Una classe Kitten \e composta da campi, costruttori e metodi. Essi devono venire tradotti
in una classe di Java bytecode che infine verr\`a salvata sul file system. Esiste una
classe BCEL, di nome \texttt{ClassGen}, che permette di generare file class e
salvarli sul file system. Conviene quindi estendere tale classe in un generatore che include
anche una fattoria e i metodi di traduzione del Kitten bytecode che abbiamo visto
nella Sezione~\ref{sec:kitten_into_java_block}. La Figura~\ref{fig:java_class_generator}
mostra tale estensione.
%
\begin{figure}

{\small
\begin{verbatim}
public class JavaClassGenerator extends ClassGen {

  private final InstructionFactory factory;

  public JavaClassGenerator(ClassType clazz) {
    super(clazz.getName(), // nome della classe
      clazz.getSuperclass() != null ?
        clazz.getSuperclass().getName() : "java.lang.Object", // superclasse
      clazz.getName() + ".kit", // file sorgente
      Constants.ACC_PUBLIC, // visibilita': public
      new String[] {}, // nessuna interfaccia
      new ConstantPoolGen()); // constant pool inizialmente vuoto

    this.factory = new InstructionFactory(getConstantPool());

    for (FieldSignature field: clazz.getFields().values())
      field.createField(this);

    for (ConstructorSignature constructor: clazz.getConstructors())
      constructor.createConstructor(this);

    for (Set<MethodSignature> s: clazz.getMethods().values())
      for (MethodSignature method: s)
        method.createMethod(this);
  }

  public final InstructionFactory getFactory() {
    return factory;
  }

  public InstructionList generateJavaBytecode(Block block) { ...Sezione 7.3 }
}
\end{verbatim}}
\caption{La classe \texttt{javaBytecodeGenerator/JavaClassGenerator.java} che implementa la
traduzione di una classe Kitten in un file class contenente Java bytecode.}
  \label{fig:java_class_generator}
\end{figure}
%
Il costruttore riceve come argomento il tipo \texttt{clazz}
della classe Kitten che si intende
tradurre in Java bytecode. Quindi specifica
il nome della classe, della sua superclasse e del file sorgente;
inoltre specifica che intendiamo costruire una classe a visibilit\`a
\texttt{public} e che non implementa alcuna interfaccia. Quindi passa
a costruire la fattoria che abbiamo usato nella generazione del codice Java
bytecode e aggiunge al file class la traduzione di tutti i campi, costruttori
e metodi in \texttt{clazz}. Quest'ultima operazione viene effettuata dai
seguenti tre metodi:

\begin{itemize}
\item Dentro \texttt{types/FieldSignature.java} definiamo

{\small\begin{verbatim}
  public void createField(JavaClassGenerator classGen) {
    classGen.addField(new FieldGen
      (Constants.ACC_PUBLIC, // campo pubblico
      getType().toBCEL(), // tipo
      name,
      classGen.getConstantPool()) // constant pool
      .getField());
  }
\end{verbatim}}

\noindent
Si noti come il tipo del campo, espresso con le classi Kitten per i tipi,
debba venire trasformato nel corrispondente tipo BCEL prima di creare il campo.
\item Dentro \texttt{types/ConstructorSignature.java} definiamo
{\small\begin{verbatim}
  public void createConstructor(JavaClassGenerator classGen) {
    MethodGen methodGen = new MethodGen
      (Constants.ACC_PUBLIC, // public
      org.apache.bcel.generic.Type.VOID, // tipo di ritorno
      getParameters().toBCEL(), // tipo dei parametri
      null, // nomi dei parametri: irrilevante per noi
      Constants.CONSTRUCTOR_NAME, // <init>
      classGen.getClassName(), // nome della classe
      classGen.generateJavaBytecode(getCode()), // istruzioni Java bytecode
      classGen.getConstantPool()); // constant pool

    methodGen.setMaxStack(); // calcoliamo quanti elementi di stack utilizza
    methodGen.setMaxLocals(); // e quante variabili locali, al massimo

    classGen.addMethod(methodGen.getMethod());
  }
\end{verbatim}}

\noindent
Quest'ultimo metodo traduce il codice del costruttore, col metodo visto nella
Sezione~\ref{sec:kitten_into_java_block}, e lo usa come bytecode
per un nuovo costruttore Java bytecode che viene aggiunto alla classe.
Si noti che in BCEL un costruttore \e semplicemente un metodo con un nome speciale
che lo identifica come costruttore. \E importante calcolare la quantit\`a
massima di locali ed elementi di stack utilizzata dal costruttore, informazione
necessaria in Java bytecode per potere determinare la dimensione del record
di attivazione per questo costruttore.

\item Dentro \texttt{types/MethodSignature.java} definiamo
{\small\begin{verbatim}
  public void createConstructor(JavaClassGenerator classGen) {
    MethodGen methodGen;

    if (getName().equals("main"))
      methodGen = new MethodGen
        (Constants.ACC_PUBLIC | Constants.ACC_STATIC, // public e static
        org.apache.bcel.generic.Type.VOID, // tipo di ritorno
        new org.apache.bcel.generic.Type[] // tipo dei parametri
          { new org.apache.bcel.generic.ArrayType("java.lang.String", 1) },
        null, // nomi dei parametri: irrilevante per noi
        "main", // nome del metodo
        classGen.getClassName(), // nome della classe
        classGen.generateJavaBytecode(getCode()), // istruzioni Java bytecode
        classGen.getConstantPool()); // constant pool
    else
      methodGen  = new MethodGen
        (Constants.ACC_PUBLIC, // public
        getReturnType().toBCEL(), // tipo di ritorno
        getParameters().toBCEL(), // tipo dei parametri
        null, // nomi dei parametri: irrilevante per noi
        getName(), // nome del metodo
        classGen.getClassName(), // nome della classe
        classGen.generateJavaBytecode(getCode()), // istruzioni Java bytecode
        classGen.getConstantPool()); // constant pool

    methodGen.setMaxStack(); // calcoliamo quanti elementi di stack utilizza
    methodGen.setMaxLocals(); // e quante variabili locali, al massimo

    classGen.addMethod(methodGen.getMethod());
  }
\end{verbatim}}

\noindent
Si tratta di codice quasi identico a quello del costruttore, se non per il fatto che
un metodo Kitten ha nome, parametri e tipo di ritorno propri e non fissi, che vanno
quindi specificati nel file class che si sta generando. Inoltre il codice precedente
gestisce il caso speciale del metodo Kitten \texttt{main}, che deve diventare il
metodo \texttt{main} di Java, quindi statico e con un parametro di tipo array di stringhe.
In questo modo, esso verr\`a invocato automaticamente dalla Java Virtual Machine come
punto di ingresso del programma quando si prover\`a a eseguire la classe generata.
\end{itemize}

Siamo finalmente nelle condizioni di effettuare la traduzione di un programma Kitten
in un insieme di file class sul file system. Basta costruire un \texttt{JavaClassGenerator}
per ogni classe del programma Kitten e salvarlo su disco. Dentro \texttt{translation/Program.java}
definiamo il metodo:
%
\begin{verbatim}
public void generateJavaBytecode() {
  for (ClassType clazz: ClassType.getAll())
    new JavaClassGenerator(clazz).getJavaClass().dump(clazz + ".class");
}
\end{verbatim}
%
Il metodo BCEL \texttt{getJavaClass()} trasforma il generatore in una
rappresentazione del file class in memoria. Essa viene infine salvata su disco
con il suo metodo \texttt{dump()}, specificando il nome del file class,
che deve coincidere con quello della classe rappresentata.
